"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bfs-path";
exports.ids = ["vendor-chunks/bfs-path"];
exports.modules = {

/***/ "(ssr)/./node_modules/bfs-path/js/es6/path.js":
/*!**********************************************!*\
  !*** ./node_modules/bfs-path/js/es6/path.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _makeLong: () => (/* reexport safe */ _posix_path__WEBPACK_IMPORTED_MODULE_0__._makeLong),\n/* harmony export */   _removeDuplicateSeps: () => (/* reexport safe */ _posix_path__WEBPACK_IMPORTED_MODULE_0__._removeDuplicateSeps),\n/* harmony export */   _replaceRegex: () => (/* reexport safe */ _posix_path__WEBPACK_IMPORTED_MODULE_0__._replaceRegex),\n/* harmony export */   basename: () => (/* reexport safe */ _posix_path__WEBPACK_IMPORTED_MODULE_0__.basename),\n/* harmony export */   delimiter: () => (/* reexport safe */ _posix_path__WEBPACK_IMPORTED_MODULE_0__.delimiter),\n/* harmony export */   dirname: () => (/* reexport safe */ _posix_path__WEBPACK_IMPORTED_MODULE_0__.dirname),\n/* harmony export */   extname: () => (/* reexport safe */ _posix_path__WEBPACK_IMPORTED_MODULE_0__.extname),\n/* harmony export */   format: () => (/* reexport safe */ _posix_path__WEBPACK_IMPORTED_MODULE_0__.format),\n/* harmony export */   isAbsolute: () => (/* reexport safe */ _posix_path__WEBPACK_IMPORTED_MODULE_0__.isAbsolute),\n/* harmony export */   join: () => (/* reexport safe */ _posix_path__WEBPACK_IMPORTED_MODULE_0__.join),\n/* harmony export */   normalize: () => (/* reexport safe */ _posix_path__WEBPACK_IMPORTED_MODULE_0__.normalize),\n/* harmony export */   parse: () => (/* reexport safe */ _posix_path__WEBPACK_IMPORTED_MODULE_0__.parse),\n/* harmony export */   posix: () => (/* binding */ posix),\n/* harmony export */   relative: () => (/* reexport safe */ _posix_path__WEBPACK_IMPORTED_MODULE_0__.relative),\n/* harmony export */   resolve: () => (/* reexport safe */ _posix_path__WEBPACK_IMPORTED_MODULE_0__.resolve),\n/* harmony export */   sep: () => (/* reexport safe */ _posix_path__WEBPACK_IMPORTED_MODULE_0__.sep),\n/* harmony export */   win32: () => (/* binding */ win32)\n/* harmony export */ });\n/* harmony import */ var _posix_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./posix_path */ \"(ssr)/./node_modules/bfs-path/js/es6/posix_path.js\");\n\n\nconst posix = _posix_path__WEBPACK_IMPORTED_MODULE_0__;\n// XXX: Typing hack: Exported so the type of this module matches NodeJS's path.\nconst win32 = _posix_path__WEBPACK_IMPORTED_MODULE_0__;\n//# sourceMappingURL=path.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmZzLXBhdGgvanMvZXM2L3BhdGguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTBDO0FBQ2I7QUFDdEIsY0FBYyx3Q0FBUztBQUM5QjtBQUNPLGNBQWMsd0NBQVM7QUFDOUIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQWRtaW5cXE9uZURyaXZlXFxEZXNrdG9wXFx2YXVsdHF1ZXN0XFxub2RlX21vZHVsZXNcXGJmcy1wYXRoXFxqc1xcZXM2XFxwYXRoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHBvc2l4UGF0aCBmcm9tICcuL3Bvc2l4X3BhdGgnO1xuZXhwb3J0ICogZnJvbSAnLi9wb3NpeF9wYXRoJztcbmV4cG9ydCBjb25zdCBwb3NpeCA9IHBvc2l4UGF0aDtcbi8vIFhYWDogVHlwaW5nIGhhY2s6IEV4cG9ydGVkIHNvIHRoZSB0eXBlIG9mIHRoaXMgbW9kdWxlIG1hdGNoZXMgTm9kZUpTJ3MgcGF0aC5cbmV4cG9ydCBjb25zdCB3aW4zMiA9IHBvc2l4UGF0aDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdGguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bfs-path/js/es6/path.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bfs-path/js/es6/posix_path.js":
/*!****************************************************!*\
  !*** ./node_modules/bfs-path/js/es6/posix_path.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _makeLong: () => (/* binding */ _makeLong),\n/* harmony export */   _removeDuplicateSeps: () => (/* binding */ _removeDuplicateSeps),\n/* harmony export */   _replaceRegex: () => (/* binding */ _replaceRegex),\n/* harmony export */   basename: () => (/* binding */ basename),\n/* harmony export */   delimiter: () => (/* binding */ delimiter),\n/* harmony export */   dirname: () => (/* binding */ dirname),\n/* harmony export */   extname: () => (/* binding */ extname),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   isAbsolute: () => (/* binding */ isAbsolute),\n/* harmony export */   join: () => (/* binding */ join),\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   relative: () => (/* binding */ relative),\n/* harmony export */   resolve: () => (/* binding */ resolve),\n/* harmony export */   sep: () => (/* binding */ sep)\n/* harmony export */ });\n/**\n * Emulates Node's `path` module. This module contains utilities for handling and\n * transforming file paths. **All** of these methods perform only string\n * transformations. The file system is not consulted to check whether paths are\n * valid.\n * @see http://nodejs.org/api/path.html\n */\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nconst splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nfunction posixSplitPath(filename) {\n    var out = splitPathRe.exec(filename);\n    out.shift();\n    return out;\n}\n/**\n * Normalize a string path, taking care of '..' and '.' parts.\n *\n * When multiple slashes are found, they're replaced by a single one; when the path contains a trailing slash, it is preserved. On Windows backslashes are used.\n * @example Usage example\n *   path.normalize('/foo/bar//baz/asdf/quux/..')\n *   // returns\n *   '/foo/bar/baz/asdf'\n * @param [String] p The path to normalize.\n * @return [String]\n */\nfunction normalize(p) {\n    // Special case: '' -> '.'\n    if (p === '') {\n        p = '.';\n    }\n    // It's very important to know if the path is relative or not, since it\n    // changes how we process .. and reconstruct the split string.\n    var absolute = p.charAt(0) === sep;\n    // Remove repeated //s\n    p = _removeDuplicateSeps(p);\n    // Try to remove as many '../' as possible, and remove '.' completely.\n    var components = p.split(sep);\n    var goodComponents = [];\n    for (var idx = 0; idx < components.length; idx++) {\n        var c = components[idx];\n        if (c === '.') {\n            continue;\n        }\n        else if (c === '..' && (absolute || (!absolute && goodComponents.length > 0 && goodComponents[0] !== '..'))) {\n            // In the absolute case: Path is relative to root, so we may pop even if\n            // goodComponents is empty (e.g. /../ => /)\n            // In the relative case: We're getting rid of a directory that preceded\n            // it (e.g. /foo/../bar -> /bar)\n            goodComponents.pop();\n        }\n        else {\n            goodComponents.push(c);\n        }\n    }\n    // Add in '.' when it's a relative path with no other nonempty components.\n    // Possible results: '.' and './' (input: [''] or [])\n    // @todo Can probably simplify this logic.\n    if (!absolute && goodComponents.length < 2) {\n        switch (goodComponents.length) {\n            case 1:\n                if (goodComponents[0] === '') {\n                    goodComponents.unshift('.');\n                }\n                break;\n            default:\n                goodComponents.push('.');\n        }\n    }\n    p = goodComponents.join(sep);\n    if (absolute && p.charAt(0) !== sep) {\n        p = sep + p;\n    }\n    return p;\n}\n/**\n * Join all arguments together and normalize the resulting path.\n *\n * Arguments must be strings.\n * @example Usage\n *   path.join('/foo', 'bar', 'baz/asdf', 'quux', '..')\n *   // returns\n *   '/foo/bar/baz/asdf'\n *\n *   path.join('foo', {}, 'bar')\n *   // throws exception\n *   TypeError: Arguments to path.join must be strings\n * @param [String,...] paths Each component of the path\n * @return [String]\n */\nfunction join(...paths) {\n    // Required: Prune any non-strings from the path. I also prune empty segments\n    // so we can do a simple join of the array.\n    var processed = [];\n    for (var i = 0; i < paths.length; i++) {\n        var segment = paths[i];\n        if (typeof segment !== 'string') {\n            throw new TypeError(\"Invalid argument type to path.join: \" + (typeof segment));\n        }\n        else if (segment !== '') {\n            processed.push(segment);\n        }\n    }\n    return normalize(processed.join(sep));\n}\n/**\n * Resolves to to an absolute path.\n *\n * If to isn't already absolute from arguments are prepended in right to left\n * order, until an absolute path is found. If after using all from paths still\n * no absolute path is found, the current working directory is used as well.\n * The resulting path is normalized, and trailing slashes are removed unless\n * the path gets resolved to the root directory. Non-string arguments are\n * ignored.\n *\n * Another way to think of it is as a sequence of cd commands in a shell.\n *\n *     path.resolve('foo/bar', '/tmp/file/', '..', 'a/../subfile')\n *\n * Is similar to:\n *\n *     cd foo/bar\n *     cd /tmp/file/\n *     cd ..\n *     cd a/../subfile\n *     pwd\n *\n * The difference is that the different paths don't need to exist and may also\n * be files.\n * @example Usage example\n *   path.resolve('/foo/bar', './baz')\n *   // returns\n *   '/foo/bar/baz'\n *\n *   path.resolve('/foo/bar', '/tmp/file/')\n *   // returns\n *   '/tmp/file'\n *\n *   path.resolve('wwwroot', 'static_files/png/', '../gif/image.gif')\n *   // if currently in /home/myself/node, it returns\n *   '/home/myself/node/wwwroot/static_files/gif/image.gif'\n * @param [String,...] paths\n * @return [String]\n */\nfunction resolve(...paths) {\n    // Monitor for invalid paths, throw out empty paths, and look for the *last*\n    // absolute path that we see.\n    var processed = [];\n    for (var i = 0; i < paths.length; i++) {\n        var p = paths[i];\n        if (typeof p !== 'string') {\n            throw new TypeError(\"Invalid argument type to path.join: \" + (typeof p));\n        }\n        else if (p !== '') {\n            // Remove anything that has occurred before this absolute path, as it\n            // doesn't matter.\n            if (p.charAt(0) === sep) {\n                processed = [];\n            }\n            processed.push(p);\n        }\n    }\n    // Special: Remove trailing slash unless it's the root\n    var resolved = normalize(processed.join(sep));\n    if (resolved.length > 1 && resolved.charAt(resolved.length - 1) === sep) {\n        return resolved.substr(0, resolved.length - 1);\n    }\n    // Special: If it doesn't start with '/', it's relative and we need to append\n    // the current directory.\n    if (resolved.charAt(0) !== sep) {\n        // Remove ./, since we're going to append the current directory.\n        if (resolved.charAt(0) === '.' && (resolved.length === 1 || resolved.charAt(1) === sep)) {\n            resolved = resolved.length === 1 ? '' : resolved.substr(2);\n        }\n        // Append the current directory, which *must* be an absolute path.\n        var cwd = process.cwd();\n        if (resolved !== '') {\n            // cwd will never end in a /... unless it's the root.\n            resolved = normalize(cwd + (cwd !== '/' ? sep : '') + resolved);\n        }\n        else {\n            resolved = cwd;\n        }\n    }\n    return resolved;\n}\n/**\n * Solve the relative path from from to to.\n *\n * At times we have two absolute paths, and we need to derive the relative path\n * from one to the other. This is actually the reverse transform of\n * path.resolve, which means we see that:\n *\n *    path.resolve(from, path.relative(from, to)) == path.resolve(to)\n *\n * @example Usage example\n *   path.relative('C:\\\\orandea\\\\test\\\\aaa', 'C:\\\\orandea\\\\impl\\\\bbb')\n *   // returns\n *   '..\\\\..\\\\impl\\\\bbb'\n *\n *   path.relative('/data/orandea/test/aaa', '/data/orandea/impl/bbb')\n *   // returns\n *   '../../impl/bbb'\n * @param [String] from\n * @param [String] to\n * @return [String]\n */\nfunction relative(from, to) {\n    var i;\n    // Alright. Let's resolve these two to absolute paths and remove any\n    // weirdness.\n    from = resolve(from);\n    to = resolve(to);\n    var fromSegs = from.split(sep);\n    var toSegs = to.split(sep);\n    // Remove the first segment on both, as it's '' (both are absolute paths)\n    toSegs.shift();\n    fromSegs.shift();\n    // There are two segments to this path:\n    // * Going *up* the directory hierarchy with '..'\n    // * Going *down* the directory hierarchy with foo/baz/bat.\n    var upCount = 0;\n    var downSegs = [];\n    // Figure out how many things in 'from' are shared with 'to'.\n    for (i = 0; i < fromSegs.length; i++) {\n        var seg = fromSegs[i];\n        if (seg === toSegs[i]) {\n            continue;\n        }\n        // The rest of 'from', including the current element, indicates how many\n        // directories we need to go up.\n        upCount = fromSegs.length - i;\n        break;\n    }\n    // The rest of 'to' indicates where we need to change to. We place this\n    // outside of the loop, as toSegs.length may be greater than fromSegs.length.\n    downSegs = toSegs.slice(i);\n    // Special case: If 'from' is '/'\n    if (fromSegs.length === 1 && fromSegs[0] === '') {\n        upCount = 0;\n    }\n    // upCount can't be greater than the number of fromSegs\n    // (cd .. from / is still /)\n    if (upCount > fromSegs.length) {\n        upCount = fromSegs.length;\n    }\n    // Create the final string!\n    var rv = '';\n    for (i = 0; i < upCount; i++) {\n        rv += '../';\n    }\n    rv += downSegs.join(sep);\n    // Special case: Remove trailing '/'. Happens if it's all up and no down.\n    if (rv.length > 1 && rv.charAt(rv.length - 1) === sep) {\n        rv = rv.substr(0, rv.length - 1);\n    }\n    return rv;\n}\n/**\n * Return the directory name of a path. Similar to the Unix `dirname` command.\n *\n * Note that BrowserFS does not validate if the path is actually a valid\n * directory.\n * @example Usage example\n *   path.dirname('/foo/bar/baz/asdf/quux')\n *   // returns\n *   '/foo/bar/baz/asdf'\n * @param [String] p The path to get the directory name of.\n * @return [String]\n */\nfunction dirname(p) {\n    // We get rid of //, but we don't modify anything else (e.g. any extraneous .\n    // and ../ are kept intact)\n    p = _removeDuplicateSeps(p);\n    var absolute = p.charAt(0) === sep;\n    var sections = p.split(sep);\n    // Do 1 if it's /foo/bar, 2 if it's /foo/bar/\n    if (sections.pop() === '' && sections.length > 0) {\n        sections.pop();\n    }\n    // # of sections needs to be > 1 if absolute, since the first section is '' for '/'.\n    // If not absolute, the first section is the first part of the path, and is OK\n    // to return.\n    if (sections.length > 1 || (sections.length === 1 && !absolute)) {\n        return sections.join(sep);\n    }\n    else if (absolute) {\n        return sep;\n    }\n    else {\n        return '.';\n    }\n}\n/**\n * Return the last portion of a path. Similar to the Unix basename command.\n * @example Usage example\n *   path.basename('/foo/bar/baz/asdf/quux.html')\n *   // returns\n *   'quux.html'\n *\n *   path.basename('/foo/bar/baz/asdf/quux.html', '.html')\n *   // returns\n *   'quux'\n * @param [String] p\n * @param [String?] ext\n * @return [String]\n */\nfunction basename(p, ext = \"\") {\n    // Special case: Normalize will modify this to '.'\n    if (p === '') {\n        return p;\n    }\n    // Normalize the string first to remove any weirdness.\n    p = normalize(p);\n    // Get the last part of the string.\n    var sections = p.split(sep);\n    var lastPart = sections[sections.length - 1];\n    // Special case: If it's empty, then we have a string like so: foo/\n    // Meaning, 'foo' is guaranteed to be a directory.\n    if (lastPart === '' && sections.length > 1) {\n        return sections[sections.length - 2];\n    }\n    // Remove the extension, if need be.\n    if (ext.length > 0) {\n        var lastPartExt = lastPart.substr(lastPart.length - ext.length);\n        if (lastPartExt === ext) {\n            return lastPart.substr(0, lastPart.length - ext.length);\n        }\n    }\n    return lastPart;\n}\n/**\n * Return the extension of the path, from the last '.' to end of string in the\n * last portion of the path. If there is no '.' in the last portion of the path\n * or the first character of it is '.', then it returns an empty string.\n * @example Usage example\n *   path.extname('index.html')\n *   // returns\n *   '.html'\n *\n *   path.extname('index.')\n *   // returns\n *   '.'\n *\n *   path.extname('index')\n *   // returns\n *   ''\n * @param [String] p\n * @return [String]\n */\nfunction extname(p) {\n    p = normalize(p);\n    var sections = p.split(sep);\n    p = sections.pop();\n    // Special case: foo/file.ext/ should return '.ext'\n    if (p === '' && sections.length > 0) {\n        p = sections.pop();\n    }\n    if (p === '..') {\n        return '';\n    }\n    var i = p.lastIndexOf('.');\n    if (i === -1 || i === 0) {\n        return '';\n    }\n    return p.substr(i);\n}\n/**\n * Checks if the given path is an absolute path.\n *\n * Despite not being documented, this is a tested part of Node's path API.\n * @param [String] p\n * @return [Boolean] True if the path appears to be an absolute path.\n */\nfunction isAbsolute(p) {\n    return p.length > 0 && p.charAt(0) === sep;\n}\n/**\n * Unknown. Undocumented.\n */\nfunction _makeLong(p) {\n    return p;\n}\n/**\n * Returns an object from a path string.\n */\nfunction parse(p) {\n    var allParts = posixSplitPath(p);\n    return {\n        root: allParts[0],\n        dir: allParts[0] + allParts[1].slice(0, -1),\n        base: allParts[2],\n        ext: allParts[3],\n        name: allParts[2].slice(0, allParts[2].length - allParts[3].length)\n    };\n}\nfunction format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n        throw new TypeError(`Parameter 'pathObject' must be an object, not ${typeof pathObject}`);\n    }\n    var root = pathObject.root || '';\n    if (typeof root !== 'string') {\n        throw new TypeError(\"'pathObject.root' must be a string or undefined, not \" +\n            typeof pathObject.root);\n    }\n    var dir = pathObject.dir ? pathObject.dir + sep : '';\n    var base = pathObject.base || '';\n    return dir + base;\n}\n// The platform-specific file separator. BrowserFS uses `/`.\nconst sep = '/';\nconst _replaceRegex = new RegExp(\"//+\", 'g');\nfunction _removeDuplicateSeps(p) {\n    p = p.replace(_replaceRegex, sep);\n    return p;\n}\n// The platform-specific path delimiter. BrowserFS uses `:`.\nconst delimiter = ':';\n//# sourceMappingURL=posix_path.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmZzLXBhdGgvanMvZXM2L3Bvc2l4X3BhdGguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLElBQUk7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHlCQUF5QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDZFQUE2RSxrQkFBa0I7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBZG1pblxcT25lRHJpdmVcXERlc2t0b3BcXHZhdWx0cXVlc3RcXG5vZGVfbW9kdWxlc1xcYmZzLXBhdGhcXGpzXFxlczZcXHBvc2l4X3BhdGguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFbXVsYXRlcyBOb2RlJ3MgYHBhdGhgIG1vZHVsZS4gVGhpcyBtb2R1bGUgY29udGFpbnMgdXRpbGl0aWVzIGZvciBoYW5kbGluZyBhbmRcbiAqIHRyYW5zZm9ybWluZyBmaWxlIHBhdGhzLiAqKkFsbCoqIG9mIHRoZXNlIG1ldGhvZHMgcGVyZm9ybSBvbmx5IHN0cmluZ1xuICogdHJhbnNmb3JtYXRpb25zLiBUaGUgZmlsZSBzeXN0ZW0gaXMgbm90IGNvbnN1bHRlZCB0byBjaGVjayB3aGV0aGVyIHBhdGhzIGFyZVxuICogdmFsaWQuXG4gKiBAc2VlIGh0dHA6Ly9ub2RlanMub3JnL2FwaS9wYXRoLmh0bWxcbiAqL1xuLy8gU3BsaXQgYSBmaWxlbmFtZSBpbnRvIFtyb290LCBkaXIsIGJhc2VuYW1lLCBleHRdLCB1bml4IHZlcnNpb25cbi8vICdyb290JyBpcyBqdXN0IGEgc2xhc2gsIG9yIG5vdGhpbmcuXG5jb25zdCBzcGxpdFBhdGhSZSA9IC9eKFxcLz98KShbXFxzXFxTXSo/KSgoPzpcXC57MSwyfXxbXlxcL10rP3wpKFxcLlteLlxcL10qfCkpKD86W1xcL10qKSQvO1xuZnVuY3Rpb24gcG9zaXhTcGxpdFBhdGgoZmlsZW5hbWUpIHtcbiAgICB2YXIgb3V0ID0gc3BsaXRQYXRoUmUuZXhlYyhmaWxlbmFtZSk7XG4gICAgb3V0LnNoaWZ0KCk7XG4gICAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogTm9ybWFsaXplIGEgc3RyaW5nIHBhdGgsIHRha2luZyBjYXJlIG9mICcuLicgYW5kICcuJyBwYXJ0cy5cbiAqXG4gKiBXaGVuIG11bHRpcGxlIHNsYXNoZXMgYXJlIGZvdW5kLCB0aGV5J3JlIHJlcGxhY2VkIGJ5IGEgc2luZ2xlIG9uZTsgd2hlbiB0aGUgcGF0aCBjb250YWlucyBhIHRyYWlsaW5nIHNsYXNoLCBpdCBpcyBwcmVzZXJ2ZWQuIE9uIFdpbmRvd3MgYmFja3NsYXNoZXMgYXJlIHVzZWQuXG4gKiBAZXhhbXBsZSBVc2FnZSBleGFtcGxlXG4gKiAgIHBhdGgubm9ybWFsaXplKCcvZm9vL2Jhci8vYmF6L2FzZGYvcXV1eC8uLicpXG4gKiAgIC8vIHJldHVybnNcbiAqICAgJy9mb28vYmFyL2Jhei9hc2RmJ1xuICogQHBhcmFtIFtTdHJpbmddIHAgVGhlIHBhdGggdG8gbm9ybWFsaXplLlxuICogQHJldHVybiBbU3RyaW5nXVxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKHApIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6ICcnIC0+ICcuJ1xuICAgIGlmIChwID09PSAnJykge1xuICAgICAgICBwID0gJy4nO1xuICAgIH1cbiAgICAvLyBJdCdzIHZlcnkgaW1wb3J0YW50IHRvIGtub3cgaWYgdGhlIHBhdGggaXMgcmVsYXRpdmUgb3Igbm90LCBzaW5jZSBpdFxuICAgIC8vIGNoYW5nZXMgaG93IHdlIHByb2Nlc3MgLi4gYW5kIHJlY29uc3RydWN0IHRoZSBzcGxpdCBzdHJpbmcuXG4gICAgdmFyIGFic29sdXRlID0gcC5jaGFyQXQoMCkgPT09IHNlcDtcbiAgICAvLyBSZW1vdmUgcmVwZWF0ZWQgLy9zXG4gICAgcCA9IF9yZW1vdmVEdXBsaWNhdGVTZXBzKHApO1xuICAgIC8vIFRyeSB0byByZW1vdmUgYXMgbWFueSAnLi4vJyBhcyBwb3NzaWJsZSwgYW5kIHJlbW92ZSAnLicgY29tcGxldGVseS5cbiAgICB2YXIgY29tcG9uZW50cyA9IHAuc3BsaXQoc2VwKTtcbiAgICB2YXIgZ29vZENvbXBvbmVudHMgPSBbXTtcbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBjb21wb25lbnRzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgdmFyIGMgPSBjb21wb25lbnRzW2lkeF07XG4gICAgICAgIGlmIChjID09PSAnLicpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPT09ICcuLicgJiYgKGFic29sdXRlIHx8ICghYWJzb2x1dGUgJiYgZ29vZENvbXBvbmVudHMubGVuZ3RoID4gMCAmJiBnb29kQ29tcG9uZW50c1swXSAhPT0gJy4uJykpKSB7XG4gICAgICAgICAgICAvLyBJbiB0aGUgYWJzb2x1dGUgY2FzZTogUGF0aCBpcyByZWxhdGl2ZSB0byByb290LCBzbyB3ZSBtYXkgcG9wIGV2ZW4gaWZcbiAgICAgICAgICAgIC8vIGdvb2RDb21wb25lbnRzIGlzIGVtcHR5IChlLmcuIC8uLi8gPT4gLylcbiAgICAgICAgICAgIC8vIEluIHRoZSByZWxhdGl2ZSBjYXNlOiBXZSdyZSBnZXR0aW5nIHJpZCBvZiBhIGRpcmVjdG9yeSB0aGF0IHByZWNlZGVkXG4gICAgICAgICAgICAvLyBpdCAoZS5nLiAvZm9vLy4uL2JhciAtPiAvYmFyKVxuICAgICAgICAgICAgZ29vZENvbXBvbmVudHMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnb29kQ29tcG9uZW50cy5wdXNoKGMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFkZCBpbiAnLicgd2hlbiBpdCdzIGEgcmVsYXRpdmUgcGF0aCB3aXRoIG5vIG90aGVyIG5vbmVtcHR5IGNvbXBvbmVudHMuXG4gICAgLy8gUG9zc2libGUgcmVzdWx0czogJy4nIGFuZCAnLi8nIChpbnB1dDogWycnXSBvciBbXSlcbiAgICAvLyBAdG9kbyBDYW4gcHJvYmFibHkgc2ltcGxpZnkgdGhpcyBsb2dpYy5cbiAgICBpZiAoIWFic29sdXRlICYmIGdvb2RDb21wb25lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgc3dpdGNoIChnb29kQ29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBpZiAoZ29vZENvbXBvbmVudHNbMF0gPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGdvb2RDb21wb25lbnRzLnVuc2hpZnQoJy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGdvb2RDb21wb25lbnRzLnB1c2goJy4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwID0gZ29vZENvbXBvbmVudHMuam9pbihzZXApO1xuICAgIGlmIChhYnNvbHV0ZSAmJiBwLmNoYXJBdCgwKSAhPT0gc2VwKSB7XG4gICAgICAgIHAgPSBzZXAgKyBwO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbn1cbi8qKlxuICogSm9pbiBhbGwgYXJndW1lbnRzIHRvZ2V0aGVyIGFuZCBub3JtYWxpemUgdGhlIHJlc3VsdGluZyBwYXRoLlxuICpcbiAqIEFyZ3VtZW50cyBtdXN0IGJlIHN0cmluZ3MuXG4gKiBAZXhhbXBsZSBVc2FnZVxuICogICBwYXRoLmpvaW4oJy9mb28nLCAnYmFyJywgJ2Jhei9hc2RmJywgJ3F1dXgnLCAnLi4nKVxuICogICAvLyByZXR1cm5zXG4gKiAgICcvZm9vL2Jhci9iYXovYXNkZidcbiAqXG4gKiAgIHBhdGguam9pbignZm9vJywge30sICdiYXInKVxuICogICAvLyB0aHJvd3MgZXhjZXB0aW9uXG4gKiAgIFR5cGVFcnJvcjogQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3NcbiAqIEBwYXJhbSBbU3RyaW5nLC4uLl0gcGF0aHMgRWFjaCBjb21wb25lbnQgb2YgdGhlIHBhdGhcbiAqIEByZXR1cm4gW1N0cmluZ11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGpvaW4oLi4ucGF0aHMpIHtcbiAgICAvLyBSZXF1aXJlZDogUHJ1bmUgYW55IG5vbi1zdHJpbmdzIGZyb20gdGhlIHBhdGguIEkgYWxzbyBwcnVuZSBlbXB0eSBzZWdtZW50c1xuICAgIC8vIHNvIHdlIGNhbiBkbyBhIHNpbXBsZSBqb2luIG9mIHRoZSBhcnJheS5cbiAgICB2YXIgcHJvY2Vzc2VkID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2VnbWVudCA9IHBhdGhzW2ldO1xuICAgICAgICBpZiAodHlwZW9mIHNlZ21lbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhcmd1bWVudCB0eXBlIHRvIHBhdGguam9pbjogXCIgKyAodHlwZW9mIHNlZ21lbnQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzZWdtZW50ICE9PSAnJykge1xuICAgICAgICAgICAgcHJvY2Vzc2VkLnB1c2goc2VnbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGl6ZShwcm9jZXNzZWQuam9pbihzZXApKTtcbn1cbi8qKlxuICogUmVzb2x2ZXMgdG8gdG8gYW4gYWJzb2x1dGUgcGF0aC5cbiAqXG4gKiBJZiB0byBpc24ndCBhbHJlYWR5IGFic29sdXRlIGZyb20gYXJndW1lbnRzIGFyZSBwcmVwZW5kZWQgaW4gcmlnaHQgdG8gbGVmdFxuICogb3JkZXIsIHVudGlsIGFuIGFic29sdXRlIHBhdGggaXMgZm91bmQuIElmIGFmdGVyIHVzaW5nIGFsbCBmcm9tIHBhdGhzIHN0aWxsXG4gKiBubyBhYnNvbHV0ZSBwYXRoIGlzIGZvdW5kLCB0aGUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeSBpcyB1c2VkIGFzIHdlbGwuXG4gKiBUaGUgcmVzdWx0aW5nIHBhdGggaXMgbm9ybWFsaXplZCwgYW5kIHRyYWlsaW5nIHNsYXNoZXMgYXJlIHJlbW92ZWQgdW5sZXNzXG4gKiB0aGUgcGF0aCBnZXRzIHJlc29sdmVkIHRvIHRoZSByb290IGRpcmVjdG9yeS4gTm9uLXN0cmluZyBhcmd1bWVudHMgYXJlXG4gKiBpZ25vcmVkLlxuICpcbiAqIEFub3RoZXIgd2F5IHRvIHRoaW5rIG9mIGl0IGlzIGFzIGEgc2VxdWVuY2Ugb2YgY2QgY29tbWFuZHMgaW4gYSBzaGVsbC5cbiAqXG4gKiAgICAgcGF0aC5yZXNvbHZlKCdmb28vYmFyJywgJy90bXAvZmlsZS8nLCAnLi4nLCAnYS8uLi9zdWJmaWxlJylcbiAqXG4gKiBJcyBzaW1pbGFyIHRvOlxuICpcbiAqICAgICBjZCBmb28vYmFyXG4gKiAgICAgY2QgL3RtcC9maWxlL1xuICogICAgIGNkIC4uXG4gKiAgICAgY2QgYS8uLi9zdWJmaWxlXG4gKiAgICAgcHdkXG4gKlxuICogVGhlIGRpZmZlcmVuY2UgaXMgdGhhdCB0aGUgZGlmZmVyZW50IHBhdGhzIGRvbid0IG5lZWQgdG8gZXhpc3QgYW5kIG1heSBhbHNvXG4gKiBiZSBmaWxlcy5cbiAqIEBleGFtcGxlIFVzYWdlIGV4YW1wbGVcbiAqICAgcGF0aC5yZXNvbHZlKCcvZm9vL2JhcicsICcuL2JheicpXG4gKiAgIC8vIHJldHVybnNcbiAqICAgJy9mb28vYmFyL2JheidcbiAqXG4gKiAgIHBhdGgucmVzb2x2ZSgnL2Zvby9iYXInLCAnL3RtcC9maWxlLycpXG4gKiAgIC8vIHJldHVybnNcbiAqICAgJy90bXAvZmlsZSdcbiAqXG4gKiAgIHBhdGgucmVzb2x2ZSgnd3d3cm9vdCcsICdzdGF0aWNfZmlsZXMvcG5nLycsICcuLi9naWYvaW1hZ2UuZ2lmJylcbiAqICAgLy8gaWYgY3VycmVudGx5IGluIC9ob21lL215c2VsZi9ub2RlLCBpdCByZXR1cm5zXG4gKiAgICcvaG9tZS9teXNlbGYvbm9kZS93d3dyb290L3N0YXRpY19maWxlcy9naWYvaW1hZ2UuZ2lmJ1xuICogQHBhcmFtIFtTdHJpbmcsLi4uXSBwYXRoc1xuICogQHJldHVybiBbU3RyaW5nXVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZSguLi5wYXRocykge1xuICAgIC8vIE1vbml0b3IgZm9yIGludmFsaWQgcGF0aHMsIHRocm93IG91dCBlbXB0eSBwYXRocywgYW5kIGxvb2sgZm9yIHRoZSAqbGFzdCpcbiAgICAvLyBhYnNvbHV0ZSBwYXRoIHRoYXQgd2Ugc2VlLlxuICAgIHZhciBwcm9jZXNzZWQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwID0gcGF0aHNbaV07XG4gICAgICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50IHR5cGUgdG8gcGF0aC5qb2luOiBcIiArICh0eXBlb2YgcCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHAgIT09ICcnKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgYW55dGhpbmcgdGhhdCBoYXMgb2NjdXJyZWQgYmVmb3JlIHRoaXMgYWJzb2x1dGUgcGF0aCwgYXMgaXRcbiAgICAgICAgICAgIC8vIGRvZXNuJ3QgbWF0dGVyLlxuICAgICAgICAgICAgaWYgKHAuY2hhckF0KDApID09PSBzZXApIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzZWQgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb2Nlc3NlZC5wdXNoKHApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFNwZWNpYWw6IFJlbW92ZSB0cmFpbGluZyBzbGFzaCB1bmxlc3MgaXQncyB0aGUgcm9vdFxuICAgIHZhciByZXNvbHZlZCA9IG5vcm1hbGl6ZShwcm9jZXNzZWQuam9pbihzZXApKTtcbiAgICBpZiAocmVzb2x2ZWQubGVuZ3RoID4gMSAmJiByZXNvbHZlZC5jaGFyQXQocmVzb2x2ZWQubGVuZ3RoIC0gMSkgPT09IHNlcCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZWQuc3Vic3RyKDAsIHJlc29sdmVkLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICAvLyBTcGVjaWFsOiBJZiBpdCBkb2Vzbid0IHN0YXJ0IHdpdGggJy8nLCBpdCdzIHJlbGF0aXZlIGFuZCB3ZSBuZWVkIHRvIGFwcGVuZFxuICAgIC8vIHRoZSBjdXJyZW50IGRpcmVjdG9yeS5cbiAgICBpZiAocmVzb2x2ZWQuY2hhckF0KDApICE9PSBzZXApIHtcbiAgICAgICAgLy8gUmVtb3ZlIC4vLCBzaW5jZSB3ZSdyZSBnb2luZyB0byBhcHBlbmQgdGhlIGN1cnJlbnQgZGlyZWN0b3J5LlxuICAgICAgICBpZiAocmVzb2x2ZWQuY2hhckF0KDApID09PSAnLicgJiYgKHJlc29sdmVkLmxlbmd0aCA9PT0gMSB8fCByZXNvbHZlZC5jaGFyQXQoMSkgPT09IHNlcCkpIHtcbiAgICAgICAgICAgIHJlc29sdmVkID0gcmVzb2x2ZWQubGVuZ3RoID09PSAxID8gJycgOiByZXNvbHZlZC5zdWJzdHIoMik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXBwZW5kIHRoZSBjdXJyZW50IGRpcmVjdG9yeSwgd2hpY2ggKm11c3QqIGJlIGFuIGFic29sdXRlIHBhdGguXG4gICAgICAgIHZhciBjd2QgPSBwcm9jZXNzLmN3ZCgpO1xuICAgICAgICBpZiAocmVzb2x2ZWQgIT09ICcnKSB7XG4gICAgICAgICAgICAvLyBjd2Qgd2lsbCBuZXZlciBlbmQgaW4gYSAvLi4uIHVubGVzcyBpdCdzIHRoZSByb290LlxuICAgICAgICAgICAgcmVzb2x2ZWQgPSBub3JtYWxpemUoY3dkICsgKGN3ZCAhPT0gJy8nID8gc2VwIDogJycpICsgcmVzb2x2ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZWQgPSBjd2Q7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc29sdmVkO1xufVxuLyoqXG4gKiBTb2x2ZSB0aGUgcmVsYXRpdmUgcGF0aCBmcm9tIGZyb20gdG8gdG8uXG4gKlxuICogQXQgdGltZXMgd2UgaGF2ZSB0d28gYWJzb2x1dGUgcGF0aHMsIGFuZCB3ZSBuZWVkIHRvIGRlcml2ZSB0aGUgcmVsYXRpdmUgcGF0aFxuICogZnJvbSBvbmUgdG8gdGhlIG90aGVyLiBUaGlzIGlzIGFjdHVhbGx5IHRoZSByZXZlcnNlIHRyYW5zZm9ybSBvZlxuICogcGF0aC5yZXNvbHZlLCB3aGljaCBtZWFucyB3ZSBzZWUgdGhhdDpcbiAqXG4gKiAgICBwYXRoLnJlc29sdmUoZnJvbSwgcGF0aC5yZWxhdGl2ZShmcm9tLCB0bykpID09IHBhdGgucmVzb2x2ZSh0bylcbiAqXG4gKiBAZXhhbXBsZSBVc2FnZSBleGFtcGxlXG4gKiAgIHBhdGgucmVsYXRpdmUoJ0M6XFxcXG9yYW5kZWFcXFxcdGVzdFxcXFxhYWEnLCAnQzpcXFxcb3JhbmRlYVxcXFxpbXBsXFxcXGJiYicpXG4gKiAgIC8vIHJldHVybnNcbiAqICAgJy4uXFxcXC4uXFxcXGltcGxcXFxcYmJiJ1xuICpcbiAqICAgcGF0aC5yZWxhdGl2ZSgnL2RhdGEvb3JhbmRlYS90ZXN0L2FhYScsICcvZGF0YS9vcmFuZGVhL2ltcGwvYmJiJylcbiAqICAgLy8gcmV0dXJuc1xuICogICAnLi4vLi4vaW1wbC9iYmInXG4gKiBAcGFyYW0gW1N0cmluZ10gZnJvbVxuICogQHBhcmFtIFtTdHJpbmddIHRvXG4gKiBAcmV0dXJuIFtTdHJpbmddXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWxhdGl2ZShmcm9tLCB0bykge1xuICAgIHZhciBpO1xuICAgIC8vIEFscmlnaHQuIExldCdzIHJlc29sdmUgdGhlc2UgdHdvIHRvIGFic29sdXRlIHBhdGhzIGFuZCByZW1vdmUgYW55XG4gICAgLy8gd2VpcmRuZXNzLlxuICAgIGZyb20gPSByZXNvbHZlKGZyb20pO1xuICAgIHRvID0gcmVzb2x2ZSh0byk7XG4gICAgdmFyIGZyb21TZWdzID0gZnJvbS5zcGxpdChzZXApO1xuICAgIHZhciB0b1NlZ3MgPSB0by5zcGxpdChzZXApO1xuICAgIC8vIFJlbW92ZSB0aGUgZmlyc3Qgc2VnbWVudCBvbiBib3RoLCBhcyBpdCdzICcnIChib3RoIGFyZSBhYnNvbHV0ZSBwYXRocylcbiAgICB0b1NlZ3Muc2hpZnQoKTtcbiAgICBmcm9tU2Vncy5zaGlmdCgpO1xuICAgIC8vIFRoZXJlIGFyZSB0d28gc2VnbWVudHMgdG8gdGhpcyBwYXRoOlxuICAgIC8vICogR29pbmcgKnVwKiB0aGUgZGlyZWN0b3J5IGhpZXJhcmNoeSB3aXRoICcuLidcbiAgICAvLyAqIEdvaW5nICpkb3duKiB0aGUgZGlyZWN0b3J5IGhpZXJhcmNoeSB3aXRoIGZvby9iYXovYmF0LlxuICAgIHZhciB1cENvdW50ID0gMDtcbiAgICB2YXIgZG93blNlZ3MgPSBbXTtcbiAgICAvLyBGaWd1cmUgb3V0IGhvdyBtYW55IHRoaW5ncyBpbiAnZnJvbScgYXJlIHNoYXJlZCB3aXRoICd0bycuXG4gICAgZm9yIChpID0gMDsgaSA8IGZyb21TZWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzZWcgPSBmcm9tU2Vnc1tpXTtcbiAgICAgICAgaWYgKHNlZyA9PT0gdG9TZWdzW2ldKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgcmVzdCBvZiAnZnJvbScsIGluY2x1ZGluZyB0aGUgY3VycmVudCBlbGVtZW50LCBpbmRpY2F0ZXMgaG93IG1hbnlcbiAgICAgICAgLy8gZGlyZWN0b3JpZXMgd2UgbmVlZCB0byBnbyB1cC5cbiAgICAgICAgdXBDb3VudCA9IGZyb21TZWdzLmxlbmd0aCAtIGk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBUaGUgcmVzdCBvZiAndG8nIGluZGljYXRlcyB3aGVyZSB3ZSBuZWVkIHRvIGNoYW5nZSB0by4gV2UgcGxhY2UgdGhpc1xuICAgIC8vIG91dHNpZGUgb2YgdGhlIGxvb3AsIGFzIHRvU2Vncy5sZW5ndGggbWF5IGJlIGdyZWF0ZXIgdGhhbiBmcm9tU2Vncy5sZW5ndGguXG4gICAgZG93blNlZ3MgPSB0b1NlZ3Muc2xpY2UoaSk7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBJZiAnZnJvbScgaXMgJy8nXG4gICAgaWYgKGZyb21TZWdzLmxlbmd0aCA9PT0gMSAmJiBmcm9tU2Vnc1swXSA9PT0gJycpIHtcbiAgICAgICAgdXBDb3VudCA9IDA7XG4gICAgfVxuICAgIC8vIHVwQ291bnQgY2FuJ3QgYmUgZ3JlYXRlciB0aGFuIHRoZSBudW1iZXIgb2YgZnJvbVNlZ3NcbiAgICAvLyAoY2QgLi4gZnJvbSAvIGlzIHN0aWxsIC8pXG4gICAgaWYgKHVwQ291bnQgPiBmcm9tU2Vncy5sZW5ndGgpIHtcbiAgICAgICAgdXBDb3VudCA9IGZyb21TZWdzLmxlbmd0aDtcbiAgICB9XG4gICAgLy8gQ3JlYXRlIHRoZSBmaW5hbCBzdHJpbmchXG4gICAgdmFyIHJ2ID0gJyc7XG4gICAgZm9yIChpID0gMDsgaSA8IHVwQ291bnQ7IGkrKykge1xuICAgICAgICBydiArPSAnLi4vJztcbiAgICB9XG4gICAgcnYgKz0gZG93blNlZ3Muam9pbihzZXApO1xuICAgIC8vIFNwZWNpYWwgY2FzZTogUmVtb3ZlIHRyYWlsaW5nICcvJy4gSGFwcGVucyBpZiBpdCdzIGFsbCB1cCBhbmQgbm8gZG93bi5cbiAgICBpZiAocnYubGVuZ3RoID4gMSAmJiBydi5jaGFyQXQocnYubGVuZ3RoIC0gMSkgPT09IHNlcCkge1xuICAgICAgICBydiA9IHJ2LnN1YnN0cigwLCBydi5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHJ2O1xufVxuLyoqXG4gKiBSZXR1cm4gdGhlIGRpcmVjdG9yeSBuYW1lIG9mIGEgcGF0aC4gU2ltaWxhciB0byB0aGUgVW5peCBgZGlybmFtZWAgY29tbWFuZC5cbiAqXG4gKiBOb3RlIHRoYXQgQnJvd3NlckZTIGRvZXMgbm90IHZhbGlkYXRlIGlmIHRoZSBwYXRoIGlzIGFjdHVhbGx5IGEgdmFsaWRcbiAqIGRpcmVjdG9yeS5cbiAqIEBleGFtcGxlIFVzYWdlIGV4YW1wbGVcbiAqICAgcGF0aC5kaXJuYW1lKCcvZm9vL2Jhci9iYXovYXNkZi9xdXV4JylcbiAqICAgLy8gcmV0dXJuc1xuICogICAnL2Zvby9iYXIvYmF6L2FzZGYnXG4gKiBAcGFyYW0gW1N0cmluZ10gcCBUaGUgcGF0aCB0byBnZXQgdGhlIGRpcmVjdG9yeSBuYW1lIG9mLlxuICogQHJldHVybiBbU3RyaW5nXVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlybmFtZShwKSB7XG4gICAgLy8gV2UgZ2V0IHJpZCBvZiAvLywgYnV0IHdlIGRvbid0IG1vZGlmeSBhbnl0aGluZyBlbHNlIChlLmcuIGFueSBleHRyYW5lb3VzIC5cbiAgICAvLyBhbmQgLi4vIGFyZSBrZXB0IGludGFjdClcbiAgICBwID0gX3JlbW92ZUR1cGxpY2F0ZVNlcHMocCk7XG4gICAgdmFyIGFic29sdXRlID0gcC5jaGFyQXQoMCkgPT09IHNlcDtcbiAgICB2YXIgc2VjdGlvbnMgPSBwLnNwbGl0KHNlcCk7XG4gICAgLy8gRG8gMSBpZiBpdCdzIC9mb28vYmFyLCAyIGlmIGl0J3MgL2Zvby9iYXIvXG4gICAgaWYgKHNlY3Rpb25zLnBvcCgpID09PSAnJyAmJiBzZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNlY3Rpb25zLnBvcCgpO1xuICAgIH1cbiAgICAvLyAjIG9mIHNlY3Rpb25zIG5lZWRzIHRvIGJlID4gMSBpZiBhYnNvbHV0ZSwgc2luY2UgdGhlIGZpcnN0IHNlY3Rpb24gaXMgJycgZm9yICcvJy5cbiAgICAvLyBJZiBub3QgYWJzb2x1dGUsIHRoZSBmaXJzdCBzZWN0aW9uIGlzIHRoZSBmaXJzdCBwYXJ0IG9mIHRoZSBwYXRoLCBhbmQgaXMgT0tcbiAgICAvLyB0byByZXR1cm4uXG4gICAgaWYgKHNlY3Rpb25zLmxlbmd0aCA+IDEgfHwgKHNlY3Rpb25zLmxlbmd0aCA9PT0gMSAmJiAhYWJzb2x1dGUpKSB7XG4gICAgICAgIHJldHVybiBzZWN0aW9ucy5qb2luKHNlcCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFic29sdXRlKSB7XG4gICAgICAgIHJldHVybiBzZXA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gJy4nO1xuICAgIH1cbn1cbi8qKlxuICogUmV0dXJuIHRoZSBsYXN0IHBvcnRpb24gb2YgYSBwYXRoLiBTaW1pbGFyIHRvIHRoZSBVbml4IGJhc2VuYW1lIGNvbW1hbmQuXG4gKiBAZXhhbXBsZSBVc2FnZSBleGFtcGxlXG4gKiAgIHBhdGguYmFzZW5hbWUoJy9mb28vYmFyL2Jhei9hc2RmL3F1dXguaHRtbCcpXG4gKiAgIC8vIHJldHVybnNcbiAqICAgJ3F1dXguaHRtbCdcbiAqXG4gKiAgIHBhdGguYmFzZW5hbWUoJy9mb28vYmFyL2Jhei9hc2RmL3F1dXguaHRtbCcsICcuaHRtbCcpXG4gKiAgIC8vIHJldHVybnNcbiAqICAgJ3F1dXgnXG4gKiBAcGFyYW0gW1N0cmluZ10gcFxuICogQHBhcmFtIFtTdHJpbmc/XSBleHRcbiAqIEByZXR1cm4gW1N0cmluZ11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhc2VuYW1lKHAsIGV4dCA9IFwiXCIpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IE5vcm1hbGl6ZSB3aWxsIG1vZGlmeSB0aGlzIHRvICcuJ1xuICAgIGlmIChwID09PSAnJykge1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIHRoZSBzdHJpbmcgZmlyc3QgdG8gcmVtb3ZlIGFueSB3ZWlyZG5lc3MuXG4gICAgcCA9IG5vcm1hbGl6ZShwKTtcbiAgICAvLyBHZXQgdGhlIGxhc3QgcGFydCBvZiB0aGUgc3RyaW5nLlxuICAgIHZhciBzZWN0aW9ucyA9IHAuc3BsaXQoc2VwKTtcbiAgICB2YXIgbGFzdFBhcnQgPSBzZWN0aW9uc1tzZWN0aW9ucy5sZW5ndGggLSAxXTtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IElmIGl0J3MgZW1wdHksIHRoZW4gd2UgaGF2ZSBhIHN0cmluZyBsaWtlIHNvOiBmb28vXG4gICAgLy8gTWVhbmluZywgJ2ZvbycgaXMgZ3VhcmFudGVlZCB0byBiZSBhIGRpcmVjdG9yeS5cbiAgICBpZiAobGFzdFBhcnQgPT09ICcnICYmIHNlY3Rpb25zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmV0dXJuIHNlY3Rpb25zW3NlY3Rpb25zLmxlbmd0aCAtIDJdO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgdGhlIGV4dGVuc2lvbiwgaWYgbmVlZCBiZS5cbiAgICBpZiAoZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGxhc3RQYXJ0RXh0ID0gbGFzdFBhcnQuc3Vic3RyKGxhc3RQYXJ0Lmxlbmd0aCAtIGV4dC5sZW5ndGgpO1xuICAgICAgICBpZiAobGFzdFBhcnRFeHQgPT09IGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGxhc3RQYXJ0LnN1YnN0cigwLCBsYXN0UGFydC5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGFzdFBhcnQ7XG59XG4vKipcbiAqIFJldHVybiB0aGUgZXh0ZW5zaW9uIG9mIHRoZSBwYXRoLCBmcm9tIHRoZSBsYXN0ICcuJyB0byBlbmQgb2Ygc3RyaW5nIGluIHRoZVxuICogbGFzdCBwb3J0aW9uIG9mIHRoZSBwYXRoLiBJZiB0aGVyZSBpcyBubyAnLicgaW4gdGhlIGxhc3QgcG9ydGlvbiBvZiB0aGUgcGF0aFxuICogb3IgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBpdCBpcyAnLicsIHRoZW4gaXQgcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcuXG4gKiBAZXhhbXBsZSBVc2FnZSBleGFtcGxlXG4gKiAgIHBhdGguZXh0bmFtZSgnaW5kZXguaHRtbCcpXG4gKiAgIC8vIHJldHVybnNcbiAqICAgJy5odG1sJ1xuICpcbiAqICAgcGF0aC5leHRuYW1lKCdpbmRleC4nKVxuICogICAvLyByZXR1cm5zXG4gKiAgICcuJ1xuICpcbiAqICAgcGF0aC5leHRuYW1lKCdpbmRleCcpXG4gKiAgIC8vIHJldHVybnNcbiAqICAgJydcbiAqIEBwYXJhbSBbU3RyaW5nXSBwXG4gKiBAcmV0dXJuIFtTdHJpbmddXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRuYW1lKHApIHtcbiAgICBwID0gbm9ybWFsaXplKHApO1xuICAgIHZhciBzZWN0aW9ucyA9IHAuc3BsaXQoc2VwKTtcbiAgICBwID0gc2VjdGlvbnMucG9wKCk7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBmb28vZmlsZS5leHQvIHNob3VsZCByZXR1cm4gJy5leHQnXG4gICAgaWYgKHAgPT09ICcnICYmIHNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcCA9IHNlY3Rpb25zLnBvcCgpO1xuICAgIH1cbiAgICBpZiAocCA9PT0gJy4uJykge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBpID0gcC5sYXN0SW5kZXhPZignLicpO1xuICAgIGlmIChpID09PSAtMSB8fCBpID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHAuc3Vic3RyKGkpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHBhdGggaXMgYW4gYWJzb2x1dGUgcGF0aC5cbiAqXG4gKiBEZXNwaXRlIG5vdCBiZWluZyBkb2N1bWVudGVkLCB0aGlzIGlzIGEgdGVzdGVkIHBhcnQgb2YgTm9kZSdzIHBhdGggQVBJLlxuICogQHBhcmFtIFtTdHJpbmddIHBcbiAqIEByZXR1cm4gW0Jvb2xlYW5dIFRydWUgaWYgdGhlIHBhdGggYXBwZWFycyB0byBiZSBhbiBhYnNvbHV0ZSBwYXRoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBYnNvbHV0ZShwKSB7XG4gICAgcmV0dXJuIHAubGVuZ3RoID4gMCAmJiBwLmNoYXJBdCgwKSA9PT0gc2VwO1xufVxuLyoqXG4gKiBVbmtub3duLiBVbmRvY3VtZW50ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfbWFrZUxvbmcocCkge1xuICAgIHJldHVybiBwO1xufVxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCBmcm9tIGEgcGF0aCBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZShwKSB7XG4gICAgdmFyIGFsbFBhcnRzID0gcG9zaXhTcGxpdFBhdGgocCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcm9vdDogYWxsUGFydHNbMF0sXG4gICAgICAgIGRpcjogYWxsUGFydHNbMF0gKyBhbGxQYXJ0c1sxXS5zbGljZSgwLCAtMSksXG4gICAgICAgIGJhc2U6IGFsbFBhcnRzWzJdLFxuICAgICAgICBleHQ6IGFsbFBhcnRzWzNdLFxuICAgICAgICBuYW1lOiBhbGxQYXJ0c1syXS5zbGljZSgwLCBhbGxQYXJ0c1syXS5sZW5ndGggLSBhbGxQYXJ0c1szXS5sZW5ndGgpXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXQocGF0aE9iamVjdCkge1xuICAgIGlmIChwYXRoT2JqZWN0ID09PSBudWxsIHx8IHR5cGVvZiBwYXRoT2JqZWN0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJ3BhdGhPYmplY3QnIG11c3QgYmUgYW4gb2JqZWN0LCBub3QgJHt0eXBlb2YgcGF0aE9iamVjdH1gKTtcbiAgICB9XG4gICAgdmFyIHJvb3QgPSBwYXRoT2JqZWN0LnJvb3QgfHwgJyc7XG4gICAgaWYgKHR5cGVvZiByb290ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ3BhdGhPYmplY3Qucm9vdCcgbXVzdCBiZSBhIHN0cmluZyBvciB1bmRlZmluZWQsIG5vdCBcIiArXG4gICAgICAgICAgICB0eXBlb2YgcGF0aE9iamVjdC5yb290KTtcbiAgICB9XG4gICAgdmFyIGRpciA9IHBhdGhPYmplY3QuZGlyID8gcGF0aE9iamVjdC5kaXIgKyBzZXAgOiAnJztcbiAgICB2YXIgYmFzZSA9IHBhdGhPYmplY3QuYmFzZSB8fCAnJztcbiAgICByZXR1cm4gZGlyICsgYmFzZTtcbn1cbi8vIFRoZSBwbGF0Zm9ybS1zcGVjaWZpYyBmaWxlIHNlcGFyYXRvci4gQnJvd3NlckZTIHVzZXMgYC9gLlxuZXhwb3J0IGNvbnN0IHNlcCA9ICcvJztcbmV4cG9ydCBjb25zdCBfcmVwbGFjZVJlZ2V4ID0gbmV3IFJlZ0V4cChcIi8vK1wiLCAnZycpO1xuZXhwb3J0IGZ1bmN0aW9uIF9yZW1vdmVEdXBsaWNhdGVTZXBzKHApIHtcbiAgICBwID0gcC5yZXBsYWNlKF9yZXBsYWNlUmVnZXgsIHNlcCk7XG4gICAgcmV0dXJuIHA7XG59XG4vLyBUaGUgcGxhdGZvcm0tc3BlY2lmaWMgcGF0aCBkZWxpbWl0ZXIuIEJyb3dzZXJGUyB1c2VzIGA6YC5cbmV4cG9ydCBjb25zdCBkZWxpbWl0ZXIgPSAnOic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb3NpeF9wYXRoLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bfs-path/js/es6/posix_path.js\n");

/***/ })

};
;